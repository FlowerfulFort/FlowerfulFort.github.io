---
title: "JUnit5 테스트 실행 방식 및 주의점"
date: 2024-10-28 13:08:00 +0900
categories: ["JUnit", "Spring Boot"]
tags: [Spring Boot, Java, JUnit, JPA]
---

몇몇 테스트를 통해 JUnit 5 의 테스트가 어떻게 돌아가는지 근본적으로 파악해보자.

### 1. static 영역의 인스턴스.

먼저, 본인이 예전에 작성했다가 지웠던 코드를 간략하게 가져왔다.
```java
@Repository
public class AccountRepository {
    private static final AtomicLong ID_GENERATOR = new AtomicLong(0);

    public long genId() {
        return ID_GENERATOR.incrementAndGet();
    }
    ...
}
```
static으로 AtomicLong을 만들고 Auto increment 하면서 ID를 생산하고 있다.

다음은 테스트 코드이다.

```java
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
@Slf4j
class GroundTest {
    AccountRepository accountRepository = new AccountRepository();

    AtomicLong atomicLong = new AtomicLong(0);

    @Test
    @Order(1)
    void _1Test() {
        log.info("static-atomic_1: {}", accountRepository.genId());
        log.info("junit-atomic_1: {}", atomicLong.incrementAndGet());
    }
    @Test
    @Order(2)
    void _2Test() {
        log.info("static-atomic_2: {}", accountRepository.genId());
        log.info("junit-atomic_2: {}", atomicLong.incrementAndGet());
    }
    @Test
    @Order(3)
    void _3Test() {
        log.info("static-atomic_3: {}", accountRepository.genId());
        log.info("junit-atomic_3: {}", atomicLong.incrementAndGet());
    }
}
```

AccountRepository와 테스트 클래스 내에서 AtomicLong을 따로 만들어 값을 비교하고 있다.

본인은 두개의 경우 다같이 1, 1, 1 이 나오는 것을 기대하였지만 아니었다.

![test-log1](/assets/images/2024-10-28/test-log.png)

클래스 스코프 내에 존재하는 atomicLong은 매번 새로 할당되며 값이 초기화되는 한편, static 영역의 인스턴스는 테스트가 끝날떄까지 다시 할당되거나 하지 않는다.

### 2. @Sql

먼저, 간단한 두 Entity를 보자.

```java
@Entity
public class Department {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private long id;

    @Length(max=255)
    private String name;
}
/* ----------------------- */
@Entity
public class Student {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private long id;

    private String name;

    @ManyToOne(fetch = FetchType.LAZY)
    private Department department;
}
```
두 엔티티 모두 ID를 자동 생성하여 인조키로 갖고, Student는 Department에 대한 N:1 참조를 갖는다.

두 엔티티에 대한 JpaRepository도 정의하였다.

```java
public interface StudentRepository extends JpaRepository<Student, Long> {}
public interface DepartmentRepository extends JpaRepository<Department, Long> {}
```

테스트에 사용할 SQL 쿼리를 보자.

```sql
insert into department (name)
values ('컴퓨터공학과'), ('인공지능학과');

insert into student (name, department_id)
values ('홍길동', 1), ('김아무개', 2);
```
department를 두개 넣고, student도 2개 만들어 각각 department에 연관을 해주었다.

이제 테스트 코드를 보자. @Sql 어노테이션을 이용하여 위의 쿼리를 테스트 전에 실행한다.
```java
@Slf4j
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
@DataJpaTest
class SqlTest {
    @Autowired
    DepartmentRepository departmentRepository;

    @Autowired
    StudentRepository studentRepository;

    @Test
    @Order(1)
    @Sql("classpath:test.sql")
    void _1Test() {
        log.info("Test 1: # of students: {}", studentRepository.count());
    }

    @Test
    @Order(2)
    @Sql("classpath:test.sql")
    void _2Test() {
        log.info("Test 2: # of students: {}", studentRepository.count());
    }
}
```
얼핏 보면 모두 값이 2로 동일한 것 아닌가? 싶다. 그러나 두번째 테스트는 실패하고 만다.
```log
INFO 34980 --- [testground] [main] SqlTest  : Test 1: # of students: 2
WARN 34980 --- [testground] [main] o.s.test.context.TestContextManager      : Caught exception while invoking 'beforeTestMethod' callback on TestExecutionListener [org.springframework.test.context.jdbc.SqlScriptsTestExecutionListener] for test method [void com.flowerfulfort.testground.test.SqlTest._2Test()] and test instance [com.flowerfulfort.testground.test.SqlTest@6d7a343f]

org.springframework.jdbc.datasource.init.ScriptStatementFailedException: Failed to execute SQL script statement #2 of class path resource [test.sql]: insert into student (name, department_id) values ('홍길동', 1), ('김아무개', 2)

...

Caused by: org.h2.jdbc.JdbcSQLIntegrityConstraintViolationException: Referential integrity constraint violation: "FKKH3M8C2TQ2TGRGMA1IYN7TVMX: PUBLIC.STUDENT FOREIGN KEY(DEPARTMENT_ID) REFERENCES PUBLIC.DEPARTMENT(ID) (CAST(1 AS BIGINT))"; SQL statement:
insert into student (name, department_id) values ('홍길동', 1), ('김아무개', 2)
...
```
첫 번째 테스트에서 로그를 출력하여 2라는 결과를 얻었지만, 두번째 테스트에서는 예외가 발생하며 실패해버린다.

로그를 보면 외래키 참조 무결성에 어긋난다고 말한다. 왜 이렇게 되는 것인지 다른 테스트를 진행해보자.

일단 문제가 되는 SQL 구문을 삭제한다.
```sql
insert into department (name)
values ('컴퓨터공학과'), ('인공지능학과');

-- insert into student (name, department_id)
-- values ('홍길동', 1), ('김아무개', 2);
```
그리고 테스트를 수정하여 department 전체를 select하여 출력해보자.
```java
    @Test
    @Order(1)
    @Sql("classpath:test.sql")
    void _1Test() {
//        log.info("Test 1: # of students: {}", studentRepository.count());
        log.info("Test 1: departments: {}", departmentRepository.findAll().toString());
    }

    @Test
    @Order(2)
    @Sql("classpath:test.sql")
    void _2Test() {
//        log.info("Test 2: # of students: {}", studentRepository.count());
        log.info("Test 2: departments: {}", departmentRepository.findAll().toString());
    }
```
결과는 다음과 같다.

```log
INFO 29964 --- [testground] [main] SqlTest  : Test 1: departments: [Department(id=1, name=컴퓨터공학과), Department(id=2, name=인공지능학과)]
INFO 29964 --- [testground] [main] SqlTest  : Test 2: departments: [Department(id=3, name=컴퓨터공학과), Department(id=4, name=인공지능학과)]
```

결론적으로, 각 테스트마다 @Sql의 쿼리를 가져와 실행하고 끝나기전에 rollback 하는건 맞지만, Auto increment 값은 계속 증가한다.

그렇다면 원래의 SQL 쿼리에서 왜 참조 무결성 오류가 난 것인지 이해할 수 있다.
```sql
insert into student (name, department_id)
values ('홍길동', 1), ('김아무개', 2);
```
이미 1번, 2번 department는 rollback되어 사라졌고, 3번, 4번 department로 새로 추가되어 1, 2번을 찾을 수 없기 때문이다...

다음부턴 AutoIncrement라고 테스트 쿼리에서도 id 안쓰고 그러지 말고 꼬박꼬박 써주자.